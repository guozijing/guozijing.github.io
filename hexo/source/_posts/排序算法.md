---
title: 排序算法
date: 2019-04-29 11:07:18
tags: 算法
categories: 算法
---

#### 最常见 面试最容易被问到的三种排序算法

> 快速排序  希尔排序  归并排序
> 以下是不全的代码，但很容易理解(本来我记在了两张纸上，但他们现在到了被揉烂的边缘\~\~\~~~~~)
---


<!-- more -->
#### 快速排序
```
nums[] //被排序的数组
void quickSort(int & nums[], int left, int right)
{
    if (left>=right) return;
    int base=nums[left]; //每一次把最左边的数移动到排序后的对应位置
    int i=left,j=right;
    while (i<=j)
    {
        while (nums[j]>=base && j>i) j--;
        if (j>i) nums[i]=nums[j];
        while (j>i && nums[i]<=base) i++;
        if (j>i) nums[j]=nums[i];
    }
    nums[i]=base;
    quickSort(nums,left,i-1);
    quickSort(nums,i+1,right);
}
```

#### 希尔排序
```
void shell (int & nums[])
{
    int length=nums.size();
    int gap=length;
    while (gap>1)
    {
        gap=gap/3+1;
        for (int i=gap;i<length;i++)
        {
            int j=i-gap;
            while (j>=0 && nums[j]>nums[i])
            {
                swap(nums[j],nums[i]);
                j=j-gap;
            }
        }
    }
}
```

#### 归并排序
```
nums[]  length 
void guibing(nums,left,right)
{
    if (left>=right) return;
    int mid=(left+right)/2;
    guibing(nums,left,mid);
    guibing(nums,mid+1,right);
    merge(nums,left,mid,right);
}
void merge(nums,left,mid,right)
{
    int temp[right-left+1];
    int i=left,j=mid+1,k=0;
    while (i<=mid && j<=right)
    {
        if (nums[i]<=nums[j])
        {
            temp[k]=nums[i];
            k++;
            i++;
        }
        else{
            temp[k]=a[j];
            k++;
            j++;
        }
    }
    if ··········;
    if ··········; //把剩下的补全
}
```